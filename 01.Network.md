Ipv4 헤더 : 기본 20바이트에 옵션+패딩이 0-40바이트까지.<br>
A,b,c 클래스 : 유니캐스트 주소<br>
D 클래스 : 멀티캐스트 주소<br>

# 7.1 네트워크 층 서비스

## 7.1.1 패킷화

- 출발지에서 유료부하를 패킷에 캡슐화<br>
- 목적지에서 패킷으로부터 유료부하를 역캡슐화<br>
- 네트워크 계층은 출발지로부터 목적지까지 유료부하의 변경이나 활용없이 전달하는 책임이 있음<br>

## 7.1.2 라우팅

- 실제 네트워크는 네트워크와 라우터의 조합이고 라우터들끼리는 서로 연결되어 있으므로 발신지에서 목적지까지의 경로가 두 개 이상 있다.<br>
- 네트워크 계층은 이런 가능 경로들 중에서 최적의 경로를 찾느느 책임이 있음.<br>

## 7.1.3 오류 제어

- 패킷은 각 라우터에서 단편화되기 때문에 오류 검사는 비효율적이므로 네트워크층에서는 오류 제어를 구현할 수는 있지만 오류 제어 문제를 무시함.<br>

## 7.1.4 흐름 제어

- 수신자가 발신자에게 데이터가 너무 많다는 것을 알리는 피드백을 함.<br>

## 7.1.5 혼잡 제어

- 혼잡: 인터넷에 너무 많은 데이터그램이 존재하는 것<br>
- 발신자가 보낸 데이터그램 수가 네트워크 혹은 라우터 용량을 초과하면 혼잡이 발생함<br>

## 7.1.6 인터넷 서비스 품질: 지연, 지터(지연의 범위), 에러율

-> 몰라도 됨<br>

## 7.1.7 보안

- 네트워크 층은 원래 보안 없이 설계되었음<br>
- 비연결형 네트워크층 보안을 위해서는 비연결형 서비스를 연결형 서비스로 변경하는 또다른 가상 계층(virtual level)이 필요함. 이 가상 계층을 IPSec이라고 함.(13장)<br>

# 7.2 패킷 교환

- 포워딩 프로세스:<br>
  패킷이 들어오면 포워딩 테이블에서 헤더에 있는 목적지 주소와 맞는 포트를 찾아서 거기로 내보냄.<br>
- 라우터는 입력 포트와 출력 포트 간에 연결을 제공하는 스위치<br>
- 라우터의 입출력 연결 방식: 데이터그램 방식, 가상 회선 방식<br>

## 7.2.1 데이터 그램 방식

- 네트워크 계층의 프로토콜은 비연결형임.<br>
- 각각의 패킷이 독립적으로 처리됨<br>
  -> 하나의 메시지가 패킷으로 나뉘어 목적지로 전달될 떼, 각각의 패킷은 서로 다른 경로를 통해 전달될 수도 있음.<br>
  패킷들의 순서또한 보장하지 않음.<br><br>

  그림보기

## 7.2.2 가상 회선 방식(연결지향 서비스)

- 하나의 메시지에 속하는 모든 패킷들은 서로 연관이 있음<br>
- 메시지의 데이터그램을 보내기 전에, 가상 연결 경로를 설정해야 함.(이 때 가상 회선 설정 요청 패킷을 소스에서 라우터, 라우터에서 라우터, 라우터에서 목적지로 전달함. 요청 패킷을 받은 각각은 확인응답을 전달함)<br>
- 가상 연결 경로 설정 이후, 데이터그램들은 동일한 경로로 전달됨<br>
- 패킷은 소스와 목적지 주소 + @로 가상회선 식별자인 "흐름 레이블"이 필요함<br>
- 패킷들의 순서를 보장함<br><br>

그림 보기<br><br>

-incoming label에 해당하는 입력포트로 들어가서 outgoing label에 해당하는 출력포트로 나감

# 7.3 성능

측정은 다음의 세 가지로 함.<br>
혼잡제어는 성능을 개선하는 큰 이슈임.

## 7.3.1 지연

### 1. 전송 지연(transmission delay) : 패킷을 보내는 데 걸리는 시간

- 첫 번째 비트가 전송선에 놓일 때: t1. 마지막 비트가 전송선에 놓일 때: t2 이라 하면 전송 지연은 t2-t1.<br>
- 패킷이 길수록 길고 빨리 전송할 수록 짧음.<br>
- Delay(tr) = 패킷 길이 / 전송 속도

### 2. 전파 지연(propagation delay) : 신호가 목적지까지 가는 시간

- 비트가 매체의 A지점에서 B지점으로 이동하는 데 걸리는 시간<br>
- 매체의 전파 속도가 빠를수록 짧음<br>
- 링크의 거리가 길수록 길어짐<br>
- Delay(pg) = 거리 / 전파 속도

### 3. 처리 지연(processing delay) : 라우터와 목적지에서의 처리 시간

- 입력 포트에서 패킷을 수신하고, 헤더를 제거하고, 오류를 탐지하고, 패킷을 출력포트 혹은 상위계층으로 전달하는 데 필요한 시간<br>
- 패킷마다 다르지만 일반적으로 평균으로 계산됨<br>
- Delay(pr) = 패킷을 처리하는 데 걸리는 시간

### 4. 큐잉 지연(queueing delay) :

- 라우터는 처리를 기다리는 패킷을 저장하는 입력 큐, 전송을 기다리는 패킷을 저장하는 출력 큐가 있음<br>
- 입력 지연과 출력 지연이 있음<br>
- Delay(qu) = 라우터의 입출력 큐에서 처리를 대기하는 시간

### 5. 총 지연(total delay)

- 라우터가 n개이면 링크는 n+1개임<br>
- total delay = (n+1)(Delay(tr) + Delay(pg)) + Delay(pr)) + (n)(Delay(qu))

## 7.3.2 처리량(throughput)

- 초당 한 지점을 통과하는 비트 수<br>
- 해당 지점의 실질적인 전송률<br>
- 여러 링크를 거치는 경우 가장 작은 bandwidth를 가지는 링크의 bandwidth값 이하의 throughput을 가짐.<br>
  -> 이 부분 문제 나올수도 있지 않나?<br>
  평균 처리량(average throughput) = minimum{TR1, TR2, ..., TRn}

## 7.3.3 패킷 손실

- 라우터의 입력 버퍼(큐)의 크기는 유한함<br>
- 버퍼가 꽉 차면 이후의 패킷은 버려짐(overflow)<br>
- 버려지면 재전송을 해야하는데, 이 경우 상황이 더 악화(overflow, 패킷 손실)될 수 있음.<br>

# 7.4 IPv4 주소

IP 주소는 호스트나 라우터가 아닌 연결의 끝단 주소<br>

## 7.4.1 IPv4 주소지정

- 2진 표기법, 10진 표기법, 16진 표기법으로 표현 가능<br>
- prefix(네트워크 식별자) | suffix(호스트 식별자)<br>
- 클래스 기반 주소지정: prefix의 길이를 고정함<br>
  prefix의 길이는 8, 16, 24비트로 나뉨 (8의 배수)<br>
  각각 A, B, C 클래스.<br>
  D 클래스는 멀티캐스트 주소를 위해 예약됨.( 컴퓨터에게 나눠주는 것이 아니라 여러 컴퓨터가 통신할 때 사용하는 주소)<br>
  E 클래스는 나중을 위해 예약됨<br>
  전체 주소공간은 A, B, C, D, E 클래스로 구분됨<br>
- 첫 번째 바이트:<br>
  A 클래스: 0-120 | 0으로 시작<br>
  B 클래스: 128-191 | 10으로 시작<br>
  C 클래스: 192-223 | 110으로 시작<br>
  D 클래스: 224-239 | 1110으로 시작<br>
  E 클래스: 240-255 | 1111으로 시작<br>
- 클래스 없는 주소지정<br>
  - A 클래스는 큰 네트워크(호스트 수가 많음), C는 작은 네트워크이므로 이 경계를 허물자고 해서 등장한 방법<br>
  - 주소부족 문제를 일시적으로 해결하는 방법<br>
  - CIDR(클래스 없는 도메인 간 라우팅) 표기법 사용 :<br>
    - [네트워크 주소/prefix length] 의 형태<br>
- 서브네팅(subnetting)<br><br>

  1. 각 서브네트워크의 주소의 수는 2의 거듭제곱 승이어야 함<br>
  2. 각 서브 네트워크의 prefix 길이는 32-log2(서브네트워크 주소 수)<br>
  3. 더 큰 서브네트워크에 주소를 먼저 할당해야 함.<br><br>

- 주소 집단화<br>

  - 작은 주소를 묶어서 더 큰 주소를 만드는 것<br>
  - 라우팅 테이블을 간소화하여 빠른 처리<br>
  - 라우팅 정보 교환 감소 -> 트래픽 절약됨<br>

-

### 7.4.1.2 네가지 프로토콜

- IPv4: 패킷화, 포워딩, 패킷 전달<br>
- ICMPv4: 네트워크층의 전송 중 오류 제어<br>
- IGMP: 멀티캐스트 도와줌<br>
- ARP: 네트워크층 주소와 링크 계층 주소를 매핑<br>

## 7.4.2 데이터그램 형식

- IP가 사용하는 패킷을 데이터그램이라고 함<br>
- 데이터그램은 가변 길이 패킷임<br>
- 헤더: 기본 20바이트, 최대 60바이트, 단 가변부분인 40바이트는 4바이트의 배수 길이로만 가능함. 각 층이 4바이트이기 때문.<br>
- 전체 길이: 20 ~ 65,535 바이트
- 기본 20바이트 구성은 5층이 있고, 각 층은 4바이트를 차지함
- 1층: <br>
  버전(4비트): 버전 4는 4, 6은 6
  헤더 길이(4비트): 데이터그램 헤더의 전체 길이를 4비트로 표현함. 4비트로는 0~15만 표현 가능. 헤더의 최대 길이는 60바이트이므로 1은 4바이트를 나타냄. ex) HLEN = 0101이면 5 -> 20바이트<br>
  서비스 유형(6비트)<br>
  전체 길이(16비트): 데이터그램 전체 바이트 수 정의. 데이터 길이 = 전체 길이 - (HLEN x 4)<br>
- 2층: 단편화에 사용. 단편화란 라우터에서 받아들일 수 있는 최대 용량 < 데이터그램 길이 일때 데이터를 분할시켜서 보내는 것<br>
  식별자(16비트): 단편화를 했을 때 어디서부터 어디까지가 같은 데이터그램인지를 나타냄<br>
  플래그(3비트): D(1)이면 단편화 가능한 데이터그램이 아니므로 해당 데이터 그램을 폐기하고 발신자에게 ICMP 오류 메시지 전송, M(0)이면 마지막 단편화, 유일한 단편화(즉 단편화되지 않은 데이터그램, M(1)이면 추후 단편이 더 존재함<br>
  단편화 오프셋(13비트): 전체 데이터그램에서 단편의 상대적 위치를 나타냄<br>
- 3층:<br>
  TTL(8비트): 통과할 수 있는 최대 홉(라우터) 수<br>
  프로토콜(8비트): IP 계층 서비스를 사용하는 상위 계층 프로토콜로 어떤 프로토콜을 사용할건지<br>
  헤더 검사합(16비트): 오류 검사용 체크섬<br>
- 4층:<br>
  발신지 주소(32비트)<br>
- 5층:<br>
  목적지 주소(32비트)<br>
- 선택사항: 네트워크 테스팅/디버깅에 사용<br>
- 패딩: 층을 4바이트까지 채우는 용도<br>
- 페이로드: 상위계층의 데이터 전달, 바이트의 정수 배<br>
- 그림 7.15: IPv4에서 검사합 계산의 예 --> 모르겠음

### 단편화

- 수신한 프레임의 형식과 크기는 프레임이 통과한 물리층에서 사용된 프로토콜에 따라 다름<br>
- ex) LAN에서 WAN으로 연결하는 라우터는 LAN 형식의 프레임을 수신하여 WAN 형식의 프레임으로 전송함

### MTU(Maximum Transfer Unit)

- 링크 계층 프로토콜마다 고유의 프레임 포맷을 가짐<br>
- 즉 링크 계층 프로토콜마다 프레임에 캡슐화할 수 있는 페이로드의 최대 크기(MTU)가 정해져있다는 뜻<br>
- 이더넷 프로토콜은 MTU가 1500 바이트임<br>
- 그림 7.17: 단편화 예제<br>
- 그림 7.18: 단편화 구체적인 예제<br>

## 7.4.3 IPv4 옵션(헤더의 가변길이에 해당하는 부분)

- 단일 바이트(1바이트) 옵션: 무동작 채우기 용도 혹은 패딩(옵션 마지막에만)<br>
- 다중 바이트 옵션: 경로 기록, 엄격한/ 유연한 발신지 경로, 타임 스탬프<br>

### IPv4의 옵션: 보안

- 원래 IPv4 프로토콜에는 보안성이 없었고 지금은 보안성이 필요함<br>
- 보안 이슈: 패킷 도청, 패킷 변조, IP 스푸핑(IP 주소 위장한 후 패킷 전송)<br>
- IPSec은 암호와 알고리즘과 키를 정의, 패킷 암호화, 데이터 무결성, 발신처 인증 기능 제공

## 7.4.4 ICMPv4

- 메시지:<br>
  - 패킷의 페이로드 안에 들어감<br>
  - 오류 보고 메시지: 라우터나 호스트가 전송 중 탐지하는 문제 <br>
  - 질의 메세지<br>
  - 둘다 type(8비트), code(8비트)가 있음<br>
  - ICMP 메시지 형식 ~ 오류 보고 메시지 종류별 형식 -> ppt 읽어보기<br>
  - 질의 메시지 종류 중 에코 요청 및 응답 메시지는 ping 등에 사용함
- 디버깅:<br>
  호스트나 라우터의 생존 능력 결정: ping<br>
  패킷의 경로 추적: traceroute<br>
- ICMP 검사합의 예제

## 7.4.5 이동 IP

- 이동 호스트와 원격 호스트의 통신 세 단계:<br>

1. 에이전트 발견: 홈 에이전트와 외지 에이전트 발견<br>
2. 등록: 외지 네트워크로 이동하여 외지 에이전트를 발견한 후 이동호스트는 등록을 함. 1) 외지 호스트에 이동 호스트 등록 2) 홈 에이전트에 외지 호스트 등록 <br>
3. 데이터 전송

- 그림 7.25 보고 설명하기
- 원격 호스트로부터 이동 호스트로의 데이터 전달: <br>

1. 원격 호스트 -> 홈 에이전트<br>
2. 홈 에이전트 -> 외지 에이전트<br>
3. 외지 에이전트 -> 이동 호스트<br>
4. 이동 호스트 -> 원격 호스트<br>

- 보통은 원격 호스트가 이동 호스트랑 같은 네트워크에 있는 것이 자주 발생(더블 크로싱 현상, 패킷이 인터넷을 두 번 지나가는 것)하는데 이는 비효율적임<br>
- 삼각라우팅: 일반적인 원격 호스트와 이동 호스트의 통신(두 호스트가 같은 네트워크가 아님.) 원격 호스트에서 이동 호스트로 바로 보내면 한 변인데 그렇지 못해서 두 변을 지나가게 되어 비효율적임.
  여기까지 연습문제 개많은데 어떻게 하지.... 근데 그게 나올거같진 않음.
  버릴까?

## 7.4.6 IP 패킷의 포워딩 ---> 이건 중요한건데?

- 포워딩에서 IP 주소의 역할을 봄<br>
- 포워딩: 패킷을 다음 홉으로 전달하는 것<br>

1. 목적지 주소기반 포워딩: 일반적으로 사용되는 방식<br>

- 다음 홉을 찾기 위해 포워딩 테이블이 필요하다.<br>
- 주소 집단화: <br>
  - 작은 네트워크 여러 개를 묶어 하나의 큰 네트워크로 표현<br>
  - 포워딩 테이블의 수가 적어져서 빠른 탐색 가능<br>
- 가장 긴 마스크 매칭: 패킷이 들어오면 포워딩 테이블에서 마스크 비트가 가장 긴, 즉 작은 네트워크 주소부터 탐색한다. 각 마스크 비트를 찾아보고 그것을 목적지 주소에 적용해 목적지 네트워크 주소를 찾는다. 매칭하면 다음 홉 주소와 인터페이스 번호를 추출한다.<br>

2. 레이블(가상회선 식별자) 기반 포워딩: 가상 회선 방식에서는 패킷에 포함된 레이블을 기반으로 패킷을 포워딩함.<br>

- 라우팅이 아닌 교환임. 즉 라우터는 교환기로 기능함.<br>
- 라우팅은 탐색이 필요하지만 교환은 지정된 레이블에 따라 포워딩 테이블의 내용을 접근하여 읽어옴. 즉 탐색 없이 바로 액세스할 수 있는 장점이 있다.<br>
- 레이블 기반 포워딩 사진<br>